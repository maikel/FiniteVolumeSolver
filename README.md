# Finite Volume Solver

This C++17 project provides a framework to solve hyperbolic equations with finite volume methods.
The framework assumes an external structured grid library like AMReX or SAMRAI to adaptively refine regions of interest.

One of the main design philosophies is to make the numerical methods re-usable and consistent across different grid implementations.
We provide some standard flux methods which can be used out-of-the-box with a large set of hyperbolic equations.
Furthermore lot of helper classes exist to generate distributed grids for data mangement which simplify and modernize the usage of libraries like AMReX or SAMRAI.

At last, this library is also capable of handling embedded boundaries in a dimensionally split setting as defined in [Klein2009].

# Overview

## Policy Pattern

To provide customization points for the many algorithmic choices in an AMR-enabled simulation we make heavily use of the so called _policy pattern_.

> **_From Wikipedia_**: In computer programming, the strategy pattern (also known as the policy pattern) is a behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use.

For each algorithmic customization point we define a concept, which is simply a set of syntactic requirements.
Any type which satisfy a particular policy concept can be used as a drop-in replacement for existing algorithms in order to adjust the method to your special needs.
The customization points are chosen to be orthogonal and thus enable to freely concentrate on a single aspect of the method. 

<details>
<summary>Click to read an example for an InitialData concept</summary>

Any type which has a member function called `void InitializeData(amrex::MultiFab& data, const amrex::Geometry& geom)` satisfies the `InitialData` concept for usage with the AMReX library.
This means in practise that an object of type `T` can be used in code as in the example

```cpp
MyInitialDataPolicy my_intial_data{};
amrex::MultiFab data = /* obtain AMReX MultiFab from somewhere */
amrex::Geometry geom = /* obtain AMReX Geometry from somewhere */
my_intial_data.InitializeData(data, geom); 
```

The notion of concepts will be part of the C++ language as of the C++20 standard. 
In compilers which will support C++20 concepts already this type requirement can be expressed in the code as

```cpp
template <typename I>
concept InitialData = requires (I& initial_data, amrex::MultiFab& data, const amrex::Geometry& geometry) {
  { initial_data.InitializeData(data, geometry) };
};

// This line checks at compile-time if the class MyInitialDataPolicy satisfies the InitialData concept.
static_assert(InitialData<MyInitialDataPolicy>);
```

[Try it on godbolt!](https://godbolt.org/z/pu0Hh4)
</details>

## Hyperbolic Equations



## GriddingAlgorithm, DimensionalSplitSystemSolver, SplitSystemSourceLevelIntegrator

When setting up a simulation we decompose the problem in roughly two parts.

1. Manage a locally refined grid containing simulation data distributed over multiple MPI ranks.
2. Set up a numerical method to solve the problem on a distributed grid.

A `PatchHierarchy` holds simulation data for each refinement level on a `PatchLevel` and can be generated by a `GriddingAlgorithm`.
A gridding algorithm generates hierarchies by using a `TaggingMethod` policy object which masks cells which need additional refinement.
The present gridding algorithms use AMReX or SAMRAI to generate patches and hierarchies to cover such tagged cells.
In addition to the `TaggingMethod` policy the `GriddingAlgorithm` also need boundary and initial conditions, given by `BoundaryCondition` and `InitialData` policies.
The boundary conditions are used in communication routines to fill the ghost cell layer touching the computational domain.

Multiple solvers can share a common gridding algorithm and will hold a member variable of type `std::shared_ptr<GriddingAlgorithm>`.
Given a shared `GriddingAlgorithm` a solver is being able to refine the patch hierarchy or to fill ghost cell boundaries at any given time of its algorithm.
Copying a `GriddingAlgorithm` by value will deeply copy all data on all MPI ranks. This can be usefull to create fall-back scenarios of a simulation.

<details>
<summary>Click to read an example for creating an initial `PatchHierarchy`</summary>
```cpp

```
</details>

### SAMRAI Repair: Task List

- [ ] Install SAMRAI via conan
- [ ] Build Doxygen Documentation
- [ ] Build AMReX Advection example
- [ ] Prepare a simple Advection example
- [ ] Check if equations register correctly with the `SAMRAI::hier::VariableDatabase`
- [ ] Make a wrapper of fub::SAMRAI::PatchHierarchy which deeply copies.
  - [ ] Given an equation allocate data for all variables of this equation
  - [ ] Provide member functions to access patch level data and hierarchy geometry
- [ ] `fub::SAMRAI::GriddingAlgorithm`
- [ ] `fub::SAMRAI::IntegratorContext`